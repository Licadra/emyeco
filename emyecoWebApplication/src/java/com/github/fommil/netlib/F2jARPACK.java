/* Copyright 2013 Samuel Halliday (generated Java and C).
 * Copyright 2003-2007 Keith Seymour (Fortran to Java translation).
 * Copyright 1992-2007 The University of Tennessee. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 * - Redistributions of source code must retain the above copyright
 *   notice, this list of conditions and the following disclaimer.
 *
 * - Redistributions in binary form must reproduce the above copyright
 *   notice, this list of conditions and the following disclaimer listed
 *   in this license in the documentation and/or other materials
 *   provided with the distribution.
 *
 * - Neither the name of the copyright holders nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.github.fommil.netlib;

/**
 * Generated by {@code F2jImplGenerator} from {@code org.netlib.arpack} in {@code net.sourceforge.f2j:arpack_combined_all:jar:0.1}.
 */
public class F2jARPACK extends com.github.fommil.netlib.ARPACK {
//  @Override
//  public void dmout(int lout, int m, int n, double[] a, int lda, int idigit, java.lang.String ifmt) {
//   org.netlib.arpack.Dmout.dmout(lout, m, n, a, 0, lda, idigit, ifmt);
//  }

//  @Override
//  public void dmout(int lout, int m, int n, double[] a, int _a_offset, int lda, int idigit, java.lang.String ifmt) {
//   org.netlib.arpack.Dmout.dmout(lout, m, n, a, _a_offset, lda, idigit, ifmt);
//  }

//  @Override
//  public void dvout(int lout, int n, double[] sx, int idigit, java.lang.String ifmt) {
//   org.netlib.arpack.Dvout.dvout(lout, n, sx, 0, idigit, ifmt);
//  }

//  @Override
//  public void dvout(int lout, int n, double[] sx, int _sx_offset, int idigit, java.lang.String ifmt) {
//   org.netlib.arpack.Dvout.dvout(lout, n, sx, _sx_offset, idigit, ifmt);
//  }

//  @Override
//  public int icnteq(int n, int[] array, int value) {
//    return org.netlib.arpack.Icnteq.icnteq(n, array, 0, value);
//  }

//  @Override
//  public int icnteq(int n, int[] array, int _array_offset, int value) {
//    return org.netlib.arpack.Icnteq.icnteq(n, array, _array_offset, value);
//  }

//  @Override
//  public void icopy(int n, int[] lx, int incx, int[] ly, int incy) {
//   org.netlib.arpack.Icopy.icopy(n, lx, 0, incx, ly, 0, incy);
//  }

//  @Override
//  public void icopy(int n, int[] lx, int _lx_offset, int incx, int[] ly, int _ly_offset, int incy) {
//   org.netlib.arpack.Icopy.icopy(n, lx, _lx_offset, incx, ly, _ly_offset, incy);
//  }

//  @Override
//  public void iset(int n, int value, int[] array, int inc) {
//   org.netlib.arpack.Iset.iset(n, value, array, 0, inc);
//  }

//  @Override
//  public void iset(int n, int value, int[] array, int _array_offset, int inc) {
//   org.netlib.arpack.Iset.iset(n, value, array, _array_offset, inc);
//  }

//  @Override
//  public void iswap(int n, int[] sx, int incx, int[] sy, int incy) {
//   org.netlib.arpack.Iswap.iswap(n, sx, 0, incx, sy, 0, incy);
//  }

//  @Override
//  public void iswap(int n, int[] sx, int _sx_offset, int incx, int[] sy, int _sy_offset, int incy) {
//   org.netlib.arpack.Iswap.iswap(n, sx, _sx_offset, incx, sy, _sy_offset, incy);
//  }

//  @Override
//  public void ivout(int lout, int n, int[] ix, int idigit, java.lang.String ifmt) {
//   org.netlib.arpack.Ivout.ivout(lout, n, ix, 0, idigit, ifmt);
//  }

//  @Override
//  public void ivout(int lout, int n, int[] ix, int _ix_offset, int idigit, java.lang.String ifmt) {
//   org.netlib.arpack.Ivout.ivout(lout, n, ix, _ix_offset, idigit, ifmt);
//  }

//  @Override
//  public void second(org.netlib.util.floatW t) {
//   org.netlib.arpack.Second.second(t);
//  }

//  @Override
//  public void smout(int lout, int m, int n, float[] a, int lda, int idigit, java.lang.String ifmt) {
//   org.netlib.arpack.Smout.smout(lout, m, n, a, 0, lda, idigit, ifmt);
//  }

//  @Override
//  public void smout(int lout, int m, int n, float[] a, int _a_offset, int lda, int idigit, java.lang.String ifmt) {
//   org.netlib.arpack.Smout.smout(lout, m, n, a, _a_offset, lda, idigit, ifmt);
//  }

//  @Override
//  public void svout(int lout, int n, float[] sx, int idigit, java.lang.String ifmt) {
//   org.netlib.arpack.Svout.svout(lout, n, sx, 0, idigit, ifmt);
//  }

//  @Override
//  public void svout(int lout, int n, float[] sx, int _sx_offset, int idigit, java.lang.String ifmt) {
//   org.netlib.arpack.Svout.svout(lout, n, sx, _sx_offset, idigit, ifmt);
//  }

//  @Override
//  public void dgetv0(org.netlib.util.intW ido, java.lang.String bmat, int itry, boolean initv, int n, int j, double[] v, int ldv, double[] resid, org.netlib.util.doubleW rnorm, int[] ipntr, double[] workd, org.netlib.util.intW ierr) {
//   org.netlib.arpack.Dgetv0.dgetv0(ido, bmat, itry, initv, n, j, v, 0, ldv, resid, 0, rnorm, ipntr, 0, workd, 0, ierr);
//  }

//  @Override
//  public void dgetv0(org.netlib.util.intW ido, java.lang.String bmat, int itry, boolean initv, int n, int j, double[] v, int _v_offset, int ldv, double[] resid, int _resid_offset, org.netlib.util.doubleW rnorm, int[] ipntr, int _ipntr_offset, double[] workd, int _workd_offset, org.netlib.util.intW ierr) {
//   org.netlib.arpack.Dgetv0.dgetv0(ido, bmat, itry, initv, n, j, v, _v_offset, ldv, resid, _resid_offset, rnorm, ipntr, _ipntr_offset, workd, _workd_offset, ierr);
//  }

//  @Override
//  public void dlaqrb(boolean wantt, int n, int ilo, int ihi, double[] h, int ldh, double[] wr, double[] wi, double[] z, org.netlib.util.intW info) {
//   org.netlib.arpack.Dlaqrb.dlaqrb(wantt, n, ilo, ihi, h, 0, ldh, wr, 0, wi, 0, z, 0, info);
//  }

//  @Override
//  public void dlaqrb(boolean wantt, int n, int ilo, int ihi, double[] h, int _h_offset, int ldh, double[] wr, int _wr_offset, double[] wi, int _wi_offset, double[] z, int _z_offset, org.netlib.util.intW info) {
//   org.netlib.arpack.Dlaqrb.dlaqrb(wantt, n, ilo, ihi, h, _h_offset, ldh, wr, _wr_offset, wi, _wi_offset, z, _z_offset, info);
//  }

//  @Override
//  public void dnaitr(org.netlib.util.intW ido, java.lang.String bmat, int n, int k, int np, int nb, double[] resid, org.netlib.util.doubleW rnorm, double[] v, int ldv, double[] h, int ldh, int[] ipntr, double[] workd, org.netlib.util.intW info) {
//   org.netlib.arpack.Dnaitr.dnaitr(ido, bmat, n, k, np, nb, resid, 0, rnorm, v, 0, ldv, h, 0, ldh, ipntr, 0, workd, 0, info);
//  }

//  @Override
//  public void dnaitr(org.netlib.util.intW ido, java.lang.String bmat, int n, int k, int np, int nb, double[] resid, int _resid_offset, org.netlib.util.doubleW rnorm, double[] v, int _v_offset, int ldv, double[] h, int _h_offset, int ldh, int[] ipntr, int _ipntr_offset, double[] workd, int _workd_offset, org.netlib.util.intW info) {
//   org.netlib.arpack.Dnaitr.dnaitr(ido, bmat, n, k, np, nb, resid, _resid_offset, rnorm, v, _v_offset, ldv, h, _h_offset, ldh, ipntr, _ipntr_offset, workd, _workd_offset, info);
//  }

//  @Override
//  public void dnapps(int n, org.netlib.util.intW kev, int np, double[] shiftr, double[] shifti, double[] v, int ldv, double[] h, int ldh, double[] resid, double[] q, int ldq, double[] workl, double[] workd) {
//   org.netlib.arpack.Dnapps.dnapps(n, kev, np, shiftr, 0, shifti, 0, v, 0, ldv, h, 0, ldh, resid, 0, q, 0, ldq, workl, 0, workd, 0);
//  }

//  @Override
//  public void dnapps(int n, org.netlib.util.intW kev, int np, double[] shiftr, int _shiftr_offset, double[] shifti, int _shifti_offset, double[] v, int _v_offset, int ldv, double[] h, int _h_offset, int ldh, double[] resid, int _resid_offset, double[] q, int _q_offset, int ldq, double[] workl, int _workl_offset, double[] workd, int _workd_offset) {
//   org.netlib.arpack.Dnapps.dnapps(n, kev, np, shiftr, _shiftr_offset, shifti, _shifti_offset, v, _v_offset, ldv, h, _h_offset, ldh, resid, _resid_offset, q, _q_offset, ldq, workl, _workl_offset, workd, _workd_offset);
//  }

//  @Override
//  public void dnaup2(org.netlib.util.intW ido, java.lang.String bmat, int n, java.lang.String which, org.netlib.util.intW nev, org.netlib.util.intW np, double tol, double[] resid, int mode, int iupd, int ishift, org.netlib.util.intW mxiter, double[] v, int ldv, double[] h, int ldh, double[] ritzr, double[] ritzi, double[] bounds, double[] q, int ldq, double[] workl, int[] ipntr, double[] workd, org.netlib.util.intW info) {
//   org.netlib.arpack.Dnaup2.dnaup2(ido, bmat, n, which, nev, np, tol, resid, 0, mode, iupd, ishift, mxiter, v, 0, ldv, h, 0, ldh, ritzr, 0, ritzi, 0, bounds, 0, q, 0, ldq, workl, 0, ipntr, 0, workd, 0, info);
//  }

//  @Override
//  public void dnaup2(org.netlib.util.intW ido, java.lang.String bmat, int n, java.lang.String which, org.netlib.util.intW nev, org.netlib.util.intW np, double tol, double[] resid, int _resid_offset, int mode, int iupd, int ishift, org.netlib.util.intW mxiter, double[] v, int _v_offset, int ldv, double[] h, int _h_offset, int ldh, double[] ritzr, int _ritzr_offset, double[] ritzi, int _ritzi_offset, double[] bounds, int _bounds_offset, double[] q, int _q_offset, int ldq, double[] workl, int _workl_offset, int[] ipntr, int _ipntr_offset, double[] workd, int _workd_offset, org.netlib.util.intW info) {
//   org.netlib.arpack.Dnaup2.dnaup2(ido, bmat, n, which, nev, np, tol, resid, _resid_offset, mode, iupd, ishift, mxiter, v, _v_offset, ldv, h, _h_offset, ldh, ritzr, _ritzr_offset, ritzi, _ritzi_offset, bounds, _bounds_offset, q, _q_offset, ldq, workl, _workl_offset, ipntr, _ipntr_offset, workd, _workd_offset, info);
//  }

  @Override
  public void dnaupd(org.netlib.util.intW ido, java.lang.String bmat, int n, java.lang.String which, int nev, org.netlib.util.doubleW tol, double[] resid, int ncv, double[] v, int ldv, int[] iparam, int[] ipntr, double[] workd, double[] workl, int lworkl, org.netlib.util.intW info) {
   org.netlib.arpack.Dnaupd.dnaupd(ido, bmat, n, which, nev, tol, resid, 0, ncv, v, 0, ldv, iparam, 0, ipntr, 0, workd, 0, workl, 0, lworkl, info);
  }

//  @Override
//  public void dnaupd(org.netlib.util.intW ido, java.lang.String bmat, int n, java.lang.String which, int nev, org.netlib.util.doubleW tol, double[] resid, int _resid_offset, int ncv, double[] v, int _v_offset, int ldv, int[] iparam, int _iparam_offset, int[] ipntr, int _ipntr_offset, double[] workd, int _workd_offset, double[] workl, int _workl_offset, int lworkl, org.netlib.util.intW info) {
//   org.netlib.arpack.Dnaupd.dnaupd(ido, bmat, n, which, nev, tol, resid, _resid_offset, ncv, v, _v_offset, ldv, iparam, _iparam_offset, ipntr, _ipntr_offset, workd, _workd_offset, workl, _workl_offset, lworkl, info);
//  }

//  @Override
//  public void dnconv(int n, double[] ritzr, double[] ritzi, double[] bounds, double tol, org.netlib.util.intW nconv) {
//   org.netlib.arpack.Dnconv.dnconv(n, ritzr, 0, ritzi, 0, bounds, 0, tol, nconv);
//  }

//  @Override
//  public void dnconv(int n, double[] ritzr, int _ritzr_offset, double[] ritzi, int _ritzi_offset, double[] bounds, int _bounds_offset, double tol, org.netlib.util.intW nconv) {
//   org.netlib.arpack.Dnconv.dnconv(n, ritzr, _ritzr_offset, ritzi, _ritzi_offset, bounds, _bounds_offset, tol, nconv);
//  }

//  @Override
//  public void dneigh(double rnorm, org.netlib.util.intW n, double[] h, int ldh, double[] ritzr, double[] ritzi, double[] bounds, double[] q, int ldq, double[] workl, org.netlib.util.intW ierr) {
//   org.netlib.arpack.Dneigh.dneigh(rnorm, n, h, 0, ldh, ritzr, 0, ritzi, 0, bounds, 0, q, 0, ldq, workl, 0, ierr);
//  }

//  @Override
//  public void dneigh(double rnorm, org.netlib.util.intW n, double[] h, int _h_offset, int ldh, double[] ritzr, int _ritzr_offset, double[] ritzi, int _ritzi_offset, double[] bounds, int _bounds_offset, double[] q, int _q_offset, int ldq, double[] workl, int _workl_offset, org.netlib.util.intW ierr) {
//   org.netlib.arpack.Dneigh.dneigh(rnorm, n, h, _h_offset, ldh, ritzr, _ritzr_offset, ritzi, _ritzi_offset, bounds, _bounds_offset, q, _q_offset, ldq, workl, _workl_offset, ierr);
//  }

  @Override
  public void dneupd(boolean rvec, java.lang.String howmny, boolean[] select, double[] dr, double[] di, double[] z, int ldz, double sigmar, double sigmai, double[] workev, java.lang.String bmat, int n, java.lang.String which, org.netlib.util.intW nev, double tol, double[] resid, int ncv, double[] v, int ldv, int[] iparam, int[] ipntr, double[] workd, double[] workl, int lworkl, org.netlib.util.intW info) {
   org.netlib.arpack.Dneupd.dneupd(rvec, howmny, select, 0, dr, 0, di, 0, z, 0, ldz, sigmar, sigmai, workev, 0, bmat, n, which, nev, tol, resid, 0, ncv, v, 0, ldv, iparam, 0, ipntr, 0, workd, 0, workl, 0, lworkl, info);
  }

//  @Override
//  public void dneupd(boolean rvec, java.lang.String howmny, boolean[] select, int _select_offset, double[] dr, int _dr_offset, double[] di, int _di_offset, double[] z, int _z_offset, int ldz, double sigmar, double sigmai, double[] workev, int _workev_offset, java.lang.String bmat, int n, java.lang.String which, org.netlib.util.intW nev, double tol, double[] resid, int _resid_offset, int ncv, double[] v, int _v_offset, int ldv, int[] iparam, int _iparam_offset, int[] ipntr, int _ipntr_offset, double[] workd, int _workd_offset, double[] workl, int _workl_offset, int lworkl, org.netlib.util.intW info) {
//   org.netlib.arpack.Dneupd.dneupd(rvec, howmny, select, _select_offset, dr, _dr_offset, di, _di_offset, z, _z_offset, ldz, sigmar, sigmai, workev, _workev_offset, bmat, n, which, nev, tol, resid, _resid_offset, ncv, v, _v_offset, ldv, iparam, _iparam_offset, ipntr, _ipntr_offset, workd, _workd_offset, workl, _workl_offset, lworkl, info);
//  }

//  @Override
//  public void dngets(int ishift, java.lang.String which, org.netlib.util.intW kev, org.netlib.util.intW np, double[] ritzr, double[] ritzi, double[] bounds, double[] shiftr, double[] shifti) {
//   org.netlib.arpack.Dngets.dngets(ishift, which, kev, np, ritzr, 0, ritzi, 0, bounds, 0, shiftr, 0, shifti, 0);
//  }

//  @Override
//  public void dngets(int ishift, java.lang.String which, org.netlib.util.intW kev, org.netlib.util.intW np, double[] ritzr, int _ritzr_offset, double[] ritzi, int _ritzi_offset, double[] bounds, int _bounds_offset, double[] shiftr, int _shiftr_offset, double[] shifti, int _shifti_offset) {
//   org.netlib.arpack.Dngets.dngets(ishift, which, kev, np, ritzr, _ritzr_offset, ritzi, _ritzi_offset, bounds, _bounds_offset, shiftr, _shiftr_offset, shifti, _shifti_offset);
//  }

//  @Override
//  public void dsaitr(org.netlib.util.intW ido, java.lang.String bmat, int n, int k, int np, int mode, double[] resid, org.netlib.util.doubleW rnorm, double[] v, int ldv, double[] h, int ldh, int[] ipntr, double[] workd, org.netlib.util.intW info) {
//   org.netlib.arpack.Dsaitr.dsaitr(ido, bmat, n, k, np, mode, resid, 0, rnorm, v, 0, ldv, h, 0, ldh, ipntr, 0, workd, 0, info);
//  }

//  @Override
//  public void dsaitr(org.netlib.util.intW ido, java.lang.String bmat, int n, int k, int np, int mode, double[] resid, int _resid_offset, org.netlib.util.doubleW rnorm, double[] v, int _v_offset, int ldv, double[] h, int _h_offset, int ldh, int[] ipntr, int _ipntr_offset, double[] workd, int _workd_offset, org.netlib.util.intW info) {
//   org.netlib.arpack.Dsaitr.dsaitr(ido, bmat, n, k, np, mode, resid, _resid_offset, rnorm, v, _v_offset, ldv, h, _h_offset, ldh, ipntr, _ipntr_offset, workd, _workd_offset, info);
//  }

//  @Override
//  public void dsapps(int n, int kev, int np, double[] shift, double[] v, int ldv, double[] h, int ldh, double[] resid, double[] q, int ldq, double[] workd) {
//   org.netlib.arpack.Dsapps.dsapps(n, kev, np, shift, 0, v, 0, ldv, h, 0, ldh, resid, 0, q, 0, ldq, workd, 0);
//  }

//  @Override
//  public void dsapps(int n, int kev, int np, double[] shift, int _shift_offset, double[] v, int _v_offset, int ldv, double[] h, int _h_offset, int ldh, double[] resid, int _resid_offset, double[] q, int _q_offset, int ldq, double[] workd, int _workd_offset) {
//   org.netlib.arpack.Dsapps.dsapps(n, kev, np, shift, _shift_offset, v, _v_offset, ldv, h, _h_offset, ldh, resid, _resid_offset, q, _q_offset, ldq, workd, _workd_offset);
//  }

//  @Override
//  public void dsaup2(org.netlib.util.intW ido, java.lang.String bmat, int n, java.lang.String which, org.netlib.util.intW nev, org.netlib.util.intW np, double tol, double[] resid, int mode, int iupd, int ishift, org.netlib.util.intW mxiter, double[] v, int ldv, double[] h, int ldh, double[] ritz, double[] bounds, double[] q, int ldq, double[] workl, int[] ipntr, double[] workd, org.netlib.util.intW info) {
//   org.netlib.arpack.Dsaup2.dsaup2(ido, bmat, n, which, nev, np, tol, resid, 0, mode, iupd, ishift, mxiter, v, 0, ldv, h, 0, ldh, ritz, 0, bounds, 0, q, 0, ldq, workl, 0, ipntr, 0, workd, 0, info);
//  }

//  @Override
//  public void dsaup2(org.netlib.util.intW ido, java.lang.String bmat, int n, java.lang.String which, org.netlib.util.intW nev, org.netlib.util.intW np, double tol, double[] resid, int _resid_offset, int mode, int iupd, int ishift, org.netlib.util.intW mxiter, double[] v, int _v_offset, int ldv, double[] h, int _h_offset, int ldh, double[] ritz, int _ritz_offset, double[] bounds, int _bounds_offset, double[] q, int _q_offset, int ldq, double[] workl, int _workl_offset, int[] ipntr, int _ipntr_offset, double[] workd, int _workd_offset, org.netlib.util.intW info) {
//   org.netlib.arpack.Dsaup2.dsaup2(ido, bmat, n, which, nev, np, tol, resid, _resid_offset, mode, iupd, ishift, mxiter, v, _v_offset, ldv, h, _h_offset, ldh, ritz, _ritz_offset, bounds, _bounds_offset, q, _q_offset, ldq, workl, _workl_offset, ipntr, _ipntr_offset, workd, _workd_offset, info);
//  }

  @Override
  public void dsaupd(org.netlib.util.intW ido, java.lang.String bmat, int n, java.lang.String which, int nev, org.netlib.util.doubleW tol, double[] resid, int ncv, double[] v, int ldv, int[] iparam, int[] ipntr, double[] workd, double[] workl, int lworkl, org.netlib.util.intW info) {
   org.netlib.arpack.Dsaupd.dsaupd(ido, bmat, n, which, nev, tol, resid, 0, ncv, v, 0, ldv, iparam, 0, ipntr, 0, workd, 0, workl, 0, lworkl, info);
  }

//  @Override
//  public void dsaupd(org.netlib.util.intW ido, java.lang.String bmat, int n, java.lang.String which, int nev, org.netlib.util.doubleW tol, double[] resid, int _resid_offset, int ncv, double[] v, int _v_offset, int ldv, int[] iparam, int _iparam_offset, int[] ipntr, int _ipntr_offset, double[] workd, int _workd_offset, double[] workl, int _workl_offset, int lworkl, org.netlib.util.intW info) {
//   org.netlib.arpack.Dsaupd.dsaupd(ido, bmat, n, which, nev, tol, resid, _resid_offset, ncv, v, _v_offset, ldv, iparam, _iparam_offset, ipntr, _ipntr_offset, workd, _workd_offset, workl, _workl_offset, lworkl, info);
//  }

//  @Override
//  public void dsconv(int n, double[] ritz, double[] bounds, double tol, org.netlib.util.intW nconv) {
//   org.netlib.arpack.Dsconv.dsconv(n, ritz, 0, bounds, 0, tol, nconv);
//  }

//  @Override
//  public void dsconv(int n, double[] ritz, int _ritz_offset, double[] bounds, int _bounds_offset, double tol, org.netlib.util.intW nconv) {
//   org.netlib.arpack.Dsconv.dsconv(n, ritz, _ritz_offset, bounds, _bounds_offset, tol, nconv);
//  }

//  @Override
//  public void dseigt(double rnorm, int n, double[] h, int ldh, double[] eig, double[] bounds, double[] workl, org.netlib.util.intW ierr) {
//   org.netlib.arpack.Dseigt.dseigt(rnorm, n, h, 0, ldh, eig, 0, bounds, 0, workl, 0, ierr);
//  }

//  @Override
//  public void dseigt(double rnorm, int n, double[] h, int _h_offset, int ldh, double[] eig, int _eig_offset, double[] bounds, int _bounds_offset, double[] workl, int _workl_offset, org.netlib.util.intW ierr) {
//   org.netlib.arpack.Dseigt.dseigt(rnorm, n, h, _h_offset, ldh, eig, _eig_offset, bounds, _bounds_offset, workl, _workl_offset, ierr);
//  }

//  @Override
//  public void dsesrt(java.lang.String which, boolean apply, int n, double[] x, int na, double[] a, int lda) {
//   org.netlib.arpack.Dsesrt.dsesrt(which, apply, n, x, 0, na, a, 0, lda);
//  }

//  @Override
//  public void dsesrt(java.lang.String which, boolean apply, int n, double[] x, int _x_offset, int na, double[] a, int _a_offset, int lda) {
//   org.netlib.arpack.Dsesrt.dsesrt(which, apply, n, x, _x_offset, na, a, _a_offset, lda);
//  }

  @Override
  public void dseupd(boolean rvec, java.lang.String howmny, boolean[] select, double[] d, double[] z, int ldz, double sigma, java.lang.String bmat, int n, java.lang.String which, org.netlib.util.intW nev, double tol, double[] resid, int ncv, double[] v, int ldv, int[] iparam, int[] ipntr, double[] workd, double[] workl, int lworkl, org.netlib.util.intW info) {
   org.netlib.arpack.Dseupd.dseupd(rvec, howmny, select, 0, d, 0, z, 0, ldz, sigma, bmat, n, which, nev, tol, resid, 0, ncv, v, 0, ldv, iparam, 0, ipntr, 0, workd, 0, workl, 0, lworkl, info);
  }

//  @Override
//  public void dseupd(boolean rvec, java.lang.String howmny, boolean[] select, int _select_offset, double[] d, int _d_offset, double[] z, int _z_offset, int ldz, double sigma, java.lang.String bmat, int n, java.lang.String which, org.netlib.util.intW nev, double tol, double[] resid, int _resid_offset, int ncv, double[] v, int _v_offset, int ldv, int[] iparam, int _iparam_offset, int[] ipntr, int _ipntr_offset, double[] workd, int _workd_offset, double[] workl, int _workl_offset, int lworkl, org.netlib.util.intW info) {
//   org.netlib.arpack.Dseupd.dseupd(rvec, howmny, select, _select_offset, d, _d_offset, z, _z_offset, ldz, sigma, bmat, n, which, nev, tol, resid, _resid_offset, ncv, v, _v_offset, ldv, iparam, _iparam_offset, ipntr, _ipntr_offset, workd, _workd_offset, workl, _workl_offset, lworkl, info);
//  }

//  @Override
//  public void dsgets(int ishift, java.lang.String which, org.netlib.util.intW kev, org.netlib.util.intW np, double[] ritz, double[] bounds, double[] shifts) {
//   org.netlib.arpack.Dsgets.dsgets(ishift, which, kev, np, ritz, 0, bounds, 0, shifts, 0);
//  }

//  @Override
//  public void dsgets(int ishift, java.lang.String which, org.netlib.util.intW kev, org.netlib.util.intW np, double[] ritz, int _ritz_offset, double[] bounds, int _bounds_offset, double[] shifts, int _shifts_offset) {
//   org.netlib.arpack.Dsgets.dsgets(ishift, which, kev, np, ritz, _ritz_offset, bounds, _bounds_offset, shifts, _shifts_offset);
//  }

//  @Override
//  public void dsortc(java.lang.String which, boolean apply, int n, double[] xreal, double[] ximag, double[] y) {
//   org.netlib.arpack.Dsortc.dsortc(which, apply, n, xreal, 0, ximag, 0, y, 0);
//  }

//  @Override
//  public void dsortc(java.lang.String which, boolean apply, int n, double[] xreal, int _xreal_offset, double[] ximag, int _ximag_offset, double[] y, int _y_offset) {
//   org.netlib.arpack.Dsortc.dsortc(which, apply, n, xreal, _xreal_offset, ximag, _ximag_offset, y, _y_offset);
//  }

//  @Override
//  public void dsortr(java.lang.String which, boolean apply, int n, double[] x1, double[] x2) {
//   org.netlib.arpack.Dsortr.dsortr(which, apply, n, x1, 0, x2, 0);
//  }

//  @Override
//  public void dsortr(java.lang.String which, boolean apply, int n, double[] x1, int _x1_offset, double[] x2, int _x2_offset) {
//   org.netlib.arpack.Dsortr.dsortr(which, apply, n, x1, _x1_offset, x2, _x2_offset);
//  }

//  @Override
//  public void dstatn() {
//   org.netlib.arpack.Dstatn.dstatn();
//  }

//  @Override
//  public void dstats() {
//   org.netlib.arpack.Dstats.dstats();
//  }

//  @Override
//  public void dstqrb(int n, double[] d, double[] e, double[] z, double[] work, org.netlib.util.intW info) {
//   org.netlib.arpack.Dstqrb.dstqrb(n, d, 0, e, 0, z, 0, work, 0, info);
//  }

//  @Override
//  public void dstqrb(int n, double[] d, int _d_offset, double[] e, int _e_offset, double[] z, int _z_offset, double[] work, int _work_offset, org.netlib.util.intW info) {
//   org.netlib.arpack.Dstqrb.dstqrb(n, d, _d_offset, e, _e_offset, z, _z_offset, work, _work_offset, info);
//  }

//  @Override
//  public void sgetv0(org.netlib.util.intW ido, java.lang.String bmat, int itry, boolean initv, int n, int j, float[] v, int ldv, float[] resid, org.netlib.util.floatW rnorm, int[] ipntr, float[] workd, org.netlib.util.intW ierr) {
//   org.netlib.arpack.Sgetv0.sgetv0(ido, bmat, itry, initv, n, j, v, 0, ldv, resid, 0, rnorm, ipntr, 0, workd, 0, ierr);
//  }

//  @Override
//  public void sgetv0(org.netlib.util.intW ido, java.lang.String bmat, int itry, boolean initv, int n, int j, float[] v, int _v_offset, int ldv, float[] resid, int _resid_offset, org.netlib.util.floatW rnorm, int[] ipntr, int _ipntr_offset, float[] workd, int _workd_offset, org.netlib.util.intW ierr) {
//   org.netlib.arpack.Sgetv0.sgetv0(ido, bmat, itry, initv, n, j, v, _v_offset, ldv, resid, _resid_offset, rnorm, ipntr, _ipntr_offset, workd, _workd_offset, ierr);
//  }

//  @Override
//  public void slaqrb(boolean wantt, int n, int ilo, int ihi, float[] h, int ldh, float[] wr, float[] wi, float[] z, org.netlib.util.intW info) {
//   org.netlib.arpack.Slaqrb.slaqrb(wantt, n, ilo, ihi, h, 0, ldh, wr, 0, wi, 0, z, 0, info);
//  }

//  @Override
//  public void slaqrb(boolean wantt, int n, int ilo, int ihi, float[] h, int _h_offset, int ldh, float[] wr, int _wr_offset, float[] wi, int _wi_offset, float[] z, int _z_offset, org.netlib.util.intW info) {
//   org.netlib.arpack.Slaqrb.slaqrb(wantt, n, ilo, ihi, h, _h_offset, ldh, wr, _wr_offset, wi, _wi_offset, z, _z_offset, info);
//  }

//  @Override
//  public void snaitr(org.netlib.util.intW ido, java.lang.String bmat, int n, int k, int np, int nb, float[] resid, org.netlib.util.floatW rnorm, float[] v, int ldv, float[] h, int ldh, int[] ipntr, float[] workd, org.netlib.util.intW info) {
//   org.netlib.arpack.Snaitr.snaitr(ido, bmat, n, k, np, nb, resid, 0, rnorm, v, 0, ldv, h, 0, ldh, ipntr, 0, workd, 0, info);
//  }

//  @Override
//  public void snaitr(org.netlib.util.intW ido, java.lang.String bmat, int n, int k, int np, int nb, float[] resid, int _resid_offset, org.netlib.util.floatW rnorm, float[] v, int _v_offset, int ldv, float[] h, int _h_offset, int ldh, int[] ipntr, int _ipntr_offset, float[] workd, int _workd_offset, org.netlib.util.intW info) {
//   org.netlib.arpack.Snaitr.snaitr(ido, bmat, n, k, np, nb, resid, _resid_offset, rnorm, v, _v_offset, ldv, h, _h_offset, ldh, ipntr, _ipntr_offset, workd, _workd_offset, info);
//  }

//  @Override
//  public void snapps(int n, org.netlib.util.intW kev, int np, float[] shiftr, float[] shifti, float[] v, int ldv, float[] h, int ldh, float[] resid, float[] q, int ldq, float[] workl, float[] workd) {
//   org.netlib.arpack.Snapps.snapps(n, kev, np, shiftr, 0, shifti, 0, v, 0, ldv, h, 0, ldh, resid, 0, q, 0, ldq, workl, 0, workd, 0);
//  }

//  @Override
//  public void snapps(int n, org.netlib.util.intW kev, int np, float[] shiftr, int _shiftr_offset, float[] shifti, int _shifti_offset, float[] v, int _v_offset, int ldv, float[] h, int _h_offset, int ldh, float[] resid, int _resid_offset, float[] q, int _q_offset, int ldq, float[] workl, int _workl_offset, float[] workd, int _workd_offset) {
//   org.netlib.arpack.Snapps.snapps(n, kev, np, shiftr, _shiftr_offset, shifti, _shifti_offset, v, _v_offset, ldv, h, _h_offset, ldh, resid, _resid_offset, q, _q_offset, ldq, workl, _workl_offset, workd, _workd_offset);
//  }

//  @Override
//  public void snaup2(org.netlib.util.intW ido, java.lang.String bmat, int n, java.lang.String which, org.netlib.util.intW nev, org.netlib.util.intW np, float tol, float[] resid, int mode, int iupd, int ishift, org.netlib.util.intW mxiter, float[] v, int ldv, float[] h, int ldh, float[] ritzr, float[] ritzi, float[] bounds, float[] q, int ldq, float[] workl, int[] ipntr, float[] workd, org.netlib.util.intW info) {
//   org.netlib.arpack.Snaup2.snaup2(ido, bmat, n, which, nev, np, tol, resid, 0, mode, iupd, ishift, mxiter, v, 0, ldv, h, 0, ldh, ritzr, 0, ritzi, 0, bounds, 0, q, 0, ldq, workl, 0, ipntr, 0, workd, 0, info);
//  }

//  @Override
//  public void snaup2(org.netlib.util.intW ido, java.lang.String bmat, int n, java.lang.String which, org.netlib.util.intW nev, org.netlib.util.intW np, float tol, float[] resid, int _resid_offset, int mode, int iupd, int ishift, org.netlib.util.intW mxiter, float[] v, int _v_offset, int ldv, float[] h, int _h_offset, int ldh, float[] ritzr, int _ritzr_offset, float[] ritzi, int _ritzi_offset, float[] bounds, int _bounds_offset, float[] q, int _q_offset, int ldq, float[] workl, int _workl_offset, int[] ipntr, int _ipntr_offset, float[] workd, int _workd_offset, org.netlib.util.intW info) {
//   org.netlib.arpack.Snaup2.snaup2(ido, bmat, n, which, nev, np, tol, resid, _resid_offset, mode, iupd, ishift, mxiter, v, _v_offset, ldv, h, _h_offset, ldh, ritzr, _ritzr_offset, ritzi, _ritzi_offset, bounds, _bounds_offset, q, _q_offset, ldq, workl, _workl_offset, ipntr, _ipntr_offset, workd, _workd_offset, info);
//  }

//  @Override
//  public void snaupd(org.netlib.util.intW ido, java.lang.String bmat, int n, java.lang.String which, int nev, org.netlib.util.floatW tol, float[] resid, int ncv, float[] v, int ldv, int[] iparam, int[] ipntr, float[] workd, float[] workl, int lworkl, org.netlib.util.intW info) {
//   org.netlib.arpack.Snaupd.snaupd(ido, bmat, n, which, nev, tol, resid, 0, ncv, v, 0, ldv, iparam, 0, ipntr, 0, workd, 0, workl, 0, lworkl, info);
//  }

//  @Override
//  public void snaupd(org.netlib.util.intW ido, java.lang.String bmat, int n, java.lang.String which, int nev, org.netlib.util.floatW tol, float[] resid, int _resid_offset, int ncv, float[] v, int _v_offset, int ldv, int[] iparam, int _iparam_offset, int[] ipntr, int _ipntr_offset, float[] workd, int _workd_offset, float[] workl, int _workl_offset, int lworkl, org.netlib.util.intW info) {
//   org.netlib.arpack.Snaupd.snaupd(ido, bmat, n, which, nev, tol, resid, _resid_offset, ncv, v, _v_offset, ldv, iparam, _iparam_offset, ipntr, _ipntr_offset, workd, _workd_offset, workl, _workl_offset, lworkl, info);
//  }

//  @Override
//  public void snconv(int n, float[] ritzr, float[] ritzi, float[] bounds, float tol, org.netlib.util.intW nconv) {
//   org.netlib.arpack.Snconv.snconv(n, ritzr, 0, ritzi, 0, bounds, 0, tol, nconv);
//  }

//  @Override
//  public void snconv(int n, float[] ritzr, int _ritzr_offset, float[] ritzi, int _ritzi_offset, float[] bounds, int _bounds_offset, float tol, org.netlib.util.intW nconv) {
//   org.netlib.arpack.Snconv.snconv(n, ritzr, _ritzr_offset, ritzi, _ritzi_offset, bounds, _bounds_offset, tol, nconv);
//  }

//  @Override
//  public void sneigh(float rnorm, org.netlib.util.intW n, float[] h, int ldh, float[] ritzr, float[] ritzi, float[] bounds, float[] q, int ldq, float[] workl, org.netlib.util.intW ierr) {
//   org.netlib.arpack.Sneigh.sneigh(rnorm, n, h, 0, ldh, ritzr, 0, ritzi, 0, bounds, 0, q, 0, ldq, workl, 0, ierr);
//  }

//  @Override
//  public void sneigh(float rnorm, org.netlib.util.intW n, float[] h, int _h_offset, int ldh, float[] ritzr, int _ritzr_offset, float[] ritzi, int _ritzi_offset, float[] bounds, int _bounds_offset, float[] q, int _q_offset, int ldq, float[] workl, int _workl_offset, org.netlib.util.intW ierr) {
//   org.netlib.arpack.Sneigh.sneigh(rnorm, n, h, _h_offset, ldh, ritzr, _ritzr_offset, ritzi, _ritzi_offset, bounds, _bounds_offset, q, _q_offset, ldq, workl, _workl_offset, ierr);
//  }

//  @Override
//  public void sneupd(boolean rvec, java.lang.String howmny, boolean[] select, float[] dr, float[] di, float[] z, int ldz, float sigmar, float sigmai, float[] workev, java.lang.String bmat, int n, java.lang.String which, org.netlib.util.intW nev, float tol, float[] resid, int ncv, float[] v, int ldv, int[] iparam, int[] ipntr, float[] workd, float[] workl, int lworkl, org.netlib.util.intW info) {
//   org.netlib.arpack.Sneupd.sneupd(rvec, howmny, select, 0, dr, 0, di, 0, z, 0, ldz, sigmar, sigmai, workev, 0, bmat, n, which, nev, tol, resid, 0, ncv, v, 0, ldv, iparam, 0, ipntr, 0, workd, 0, workl, 0, lworkl, info);
//  }

//  @Override
//  public void sneupd(boolean rvec, java.lang.String howmny, boolean[] select, int _select_offset, float[] dr, int _dr_offset, float[] di, int _di_offset, float[] z, int _z_offset, int ldz, float sigmar, float sigmai, float[] workev, int _workev_offset, java.lang.String bmat, int n, java.lang.String which, org.netlib.util.intW nev, float tol, float[] resid, int _resid_offset, int ncv, float[] v, int _v_offset, int ldv, int[] iparam, int _iparam_offset, int[] ipntr, int _ipntr_offset, float[] workd, int _workd_offset, float[] workl, int _workl_offset, int lworkl, org.netlib.util.intW info) {
//   org.netlib.arpack.Sneupd.sneupd(rvec, howmny, select, _select_offset, dr, _dr_offset, di, _di_offset, z, _z_offset, ldz, sigmar, sigmai, workev, _workev_offset, bmat, n, which, nev, tol, resid, _resid_offset, ncv, v, _v_offset, ldv, iparam, _iparam_offset, ipntr, _ipntr_offset, workd, _workd_offset, workl, _workl_offset, lworkl, info);
//  }

//  @Override
//  public void sngets(int ishift, java.lang.String which, org.netlib.util.intW kev, org.netlib.util.intW np, float[] ritzr, float[] ritzi, float[] bounds, float[] shiftr, float[] shifti) {
//   org.netlib.arpack.Sngets.sngets(ishift, which, kev, np, ritzr, 0, ritzi, 0, bounds, 0, shiftr, 0, shifti, 0);
//  }

//  @Override
//  public void sngets(int ishift, java.lang.String which, org.netlib.util.intW kev, org.netlib.util.intW np, float[] ritzr, int _ritzr_offset, float[] ritzi, int _ritzi_offset, float[] bounds, int _bounds_offset, float[] shiftr, int _shiftr_offset, float[] shifti, int _shifti_offset) {
//   org.netlib.arpack.Sngets.sngets(ishift, which, kev, np, ritzr, _ritzr_offset, ritzi, _ritzi_offset, bounds, _bounds_offset, shiftr, _shiftr_offset, shifti, _shifti_offset);
//  }

//  @Override
//  public void ssaitr(org.netlib.util.intW ido, java.lang.String bmat, int n, int k, int np, int mode, float[] resid, org.netlib.util.floatW rnorm, float[] v, int ldv, float[] h, int ldh, int[] ipntr, float[] workd, org.netlib.util.intW info) {
//   org.netlib.arpack.Ssaitr.ssaitr(ido, bmat, n, k, np, mode, resid, 0, rnorm, v, 0, ldv, h, 0, ldh, ipntr, 0, workd, 0, info);
//  }

//  @Override
//  public void ssaitr(org.netlib.util.intW ido, java.lang.String bmat, int n, int k, int np, int mode, float[] resid, int _resid_offset, org.netlib.util.floatW rnorm, float[] v, int _v_offset, int ldv, float[] h, int _h_offset, int ldh, int[] ipntr, int _ipntr_offset, float[] workd, int _workd_offset, org.netlib.util.intW info) {
//   org.netlib.arpack.Ssaitr.ssaitr(ido, bmat, n, k, np, mode, resid, _resid_offset, rnorm, v, _v_offset, ldv, h, _h_offset, ldh, ipntr, _ipntr_offset, workd, _workd_offset, info);
//  }

//  @Override
//  public void ssapps(int n, int kev, int np, float[] shift, float[] v, int ldv, float[] h, int ldh, float[] resid, float[] q, int ldq, float[] workd) {
//   org.netlib.arpack.Ssapps.ssapps(n, kev, np, shift, 0, v, 0, ldv, h, 0, ldh, resid, 0, q, 0, ldq, workd, 0);
//  }

//  @Override
//  public void ssapps(int n, int kev, int np, float[] shift, int _shift_offset, float[] v, int _v_offset, int ldv, float[] h, int _h_offset, int ldh, float[] resid, int _resid_offset, float[] q, int _q_offset, int ldq, float[] workd, int _workd_offset) {
//   org.netlib.arpack.Ssapps.ssapps(n, kev, np, shift, _shift_offset, v, _v_offset, ldv, h, _h_offset, ldh, resid, _resid_offset, q, _q_offset, ldq, workd, _workd_offset);
//  }

//  @Override
//  public void ssaup2(org.netlib.util.intW ido, java.lang.String bmat, int n, java.lang.String which, org.netlib.util.intW nev, org.netlib.util.intW np, float tol, float[] resid, int mode, int iupd, int ishift, org.netlib.util.intW mxiter, float[] v, int ldv, float[] h, int ldh, float[] ritz, float[] bounds, float[] q, int ldq, float[] workl, int[] ipntr, float[] workd, org.netlib.util.intW info) {
//   org.netlib.arpack.Ssaup2.ssaup2(ido, bmat, n, which, nev, np, tol, resid, 0, mode, iupd, ishift, mxiter, v, 0, ldv, h, 0, ldh, ritz, 0, bounds, 0, q, 0, ldq, workl, 0, ipntr, 0, workd, 0, info);
//  }

//  @Override
//  public void ssaup2(org.netlib.util.intW ido, java.lang.String bmat, int n, java.lang.String which, org.netlib.util.intW nev, org.netlib.util.intW np, float tol, float[] resid, int _resid_offset, int mode, int iupd, int ishift, org.netlib.util.intW mxiter, float[] v, int _v_offset, int ldv, float[] h, int _h_offset, int ldh, float[] ritz, int _ritz_offset, float[] bounds, int _bounds_offset, float[] q, int _q_offset, int ldq, float[] workl, int _workl_offset, int[] ipntr, int _ipntr_offset, float[] workd, int _workd_offset, org.netlib.util.intW info) {
//   org.netlib.arpack.Ssaup2.ssaup2(ido, bmat, n, which, nev, np, tol, resid, _resid_offset, mode, iupd, ishift, mxiter, v, _v_offset, ldv, h, _h_offset, ldh, ritz, _ritz_offset, bounds, _bounds_offset, q, _q_offset, ldq, workl, _workl_offset, ipntr, _ipntr_offset, workd, _workd_offset, info);
//  }

//  @Override
//  public void ssaupd(org.netlib.util.intW ido, java.lang.String bmat, int n, java.lang.String which, int nev, org.netlib.util.floatW tol, float[] resid, int ncv, float[] v, int ldv, int[] iparam, int[] ipntr, float[] workd, float[] workl, int lworkl, org.netlib.util.intW info) {
//   org.netlib.arpack.Ssaupd.ssaupd(ido, bmat, n, which, nev, tol, resid, 0, ncv, v, 0, ldv, iparam, 0, ipntr, 0, workd, 0, workl, 0, lworkl, info);
//  }

//  @Override
//  public void ssaupd(org.netlib.util.intW ido, java.lang.String bmat, int n, java.lang.String which, int nev, org.netlib.util.floatW tol, float[] resid, int _resid_offset, int ncv, float[] v, int _v_offset, int ldv, int[] iparam, int _iparam_offset, int[] ipntr, int _ipntr_offset, float[] workd, int _workd_offset, float[] workl, int _workl_offset, int lworkl, org.netlib.util.intW info) {
//   org.netlib.arpack.Ssaupd.ssaupd(ido, bmat, n, which, nev, tol, resid, _resid_offset, ncv, v, _v_offset, ldv, iparam, _iparam_offset, ipntr, _ipntr_offset, workd, _workd_offset, workl, _workl_offset, lworkl, info);
//  }

//  @Override
//  public void ssconv(int n, float[] ritz, float[] bounds, float tol, org.netlib.util.intW nconv) {
//   org.netlib.arpack.Ssconv.ssconv(n, ritz, 0, bounds, 0, tol, nconv);
//  }

//  @Override
//  public void ssconv(int n, float[] ritz, int _ritz_offset, float[] bounds, int _bounds_offset, float tol, org.netlib.util.intW nconv) {
//   org.netlib.arpack.Ssconv.ssconv(n, ritz, _ritz_offset, bounds, _bounds_offset, tol, nconv);
//  }

//  @Override
//  public void sseigt(float rnorm, int n, float[] h, int ldh, float[] eig, float[] bounds, float[] workl, org.netlib.util.intW ierr) {
//   org.netlib.arpack.Sseigt.sseigt(rnorm, n, h, 0, ldh, eig, 0, bounds, 0, workl, 0, ierr);
//  }

//  @Override
//  public void sseigt(float rnorm, int n, float[] h, int _h_offset, int ldh, float[] eig, int _eig_offset, float[] bounds, int _bounds_offset, float[] workl, int _workl_offset, org.netlib.util.intW ierr) {
//   org.netlib.arpack.Sseigt.sseigt(rnorm, n, h, _h_offset, ldh, eig, _eig_offset, bounds, _bounds_offset, workl, _workl_offset, ierr);
//  }

//  @Override
//  public void ssesrt(java.lang.String which, boolean apply, int n, float[] x, int na, float[] a, int lda) {
//   org.netlib.arpack.Ssesrt.ssesrt(which, apply, n, x, 0, na, a, 0, lda);
//  }

//  @Override
//  public void ssesrt(java.lang.String which, boolean apply, int n, float[] x, int _x_offset, int na, float[] a, int _a_offset, int lda) {
//   org.netlib.arpack.Ssesrt.ssesrt(which, apply, n, x, _x_offset, na, a, _a_offset, lda);
//  }

//  @Override
//  public void sseupd(boolean rvec, java.lang.String howmny, boolean[] select, float[] d, float[] z, int ldz, float sigma, java.lang.String bmat, int n, java.lang.String which, org.netlib.util.intW nev, float tol, float[] resid, int ncv, float[] v, int ldv, int[] iparam, int[] ipntr, float[] workd, float[] workl, int lworkl, org.netlib.util.intW info) {
//   org.netlib.arpack.Sseupd.sseupd(rvec, howmny, select, 0, d, 0, z, 0, ldz, sigma, bmat, n, which, nev, tol, resid, 0, ncv, v, 0, ldv, iparam, 0, ipntr, 0, workd, 0, workl, 0, lworkl, info);
//  }

//  @Override
//  public void sseupd(boolean rvec, java.lang.String howmny, boolean[] select, int _select_offset, float[] d, int _d_offset, float[] z, int _z_offset, int ldz, float sigma, java.lang.String bmat, int n, java.lang.String which, org.netlib.util.intW nev, float tol, float[] resid, int _resid_offset, int ncv, float[] v, int _v_offset, int ldv, int[] iparam, int _iparam_offset, int[] ipntr, int _ipntr_offset, float[] workd, int _workd_offset, float[] workl, int _workl_offset, int lworkl, org.netlib.util.intW info) {
//   org.netlib.arpack.Sseupd.sseupd(rvec, howmny, select, _select_offset, d, _d_offset, z, _z_offset, ldz, sigma, bmat, n, which, nev, tol, resid, _resid_offset, ncv, v, _v_offset, ldv, iparam, _iparam_offset, ipntr, _ipntr_offset, workd, _workd_offset, workl, _workl_offset, lworkl, info);
//  }

//  @Override
//  public void ssgets(int ishift, java.lang.String which, org.netlib.util.intW kev, org.netlib.util.intW np, float[] ritz, float[] bounds, float[] shifts) {
//   org.netlib.arpack.Ssgets.ssgets(ishift, which, kev, np, ritz, 0, bounds, 0, shifts, 0);
//  }

//  @Override
//  public void ssgets(int ishift, java.lang.String which, org.netlib.util.intW kev, org.netlib.util.intW np, float[] ritz, int _ritz_offset, float[] bounds, int _bounds_offset, float[] shifts, int _shifts_offset) {
//   org.netlib.arpack.Ssgets.ssgets(ishift, which, kev, np, ritz, _ritz_offset, bounds, _bounds_offset, shifts, _shifts_offset);
//  }

//  @Override
//  public void ssortc(java.lang.String which, boolean apply, int n, float[] xreal, float[] ximag, float[] y) {
//   org.netlib.arpack.Ssortc.ssortc(which, apply, n, xreal, 0, ximag, 0, y, 0);
//  }

//  @Override
//  public void ssortc(java.lang.String which, boolean apply, int n, float[] xreal, int _xreal_offset, float[] ximag, int _ximag_offset, float[] y, int _y_offset) {
//   org.netlib.arpack.Ssortc.ssortc(which, apply, n, xreal, _xreal_offset, ximag, _ximag_offset, y, _y_offset);
//  }

//  @Override
//  public void ssortr(java.lang.String which, boolean apply, int n, float[] x1, float[] x2) {
//   org.netlib.arpack.Ssortr.ssortr(which, apply, n, x1, 0, x2, 0);
//  }

//  @Override
//  public void ssortr(java.lang.String which, boolean apply, int n, float[] x1, int _x1_offset, float[] x2, int _x2_offset) {
//   org.netlib.arpack.Ssortr.ssortr(which, apply, n, x1, _x1_offset, x2, _x2_offset);
//  }

//  @Override
//  public void sstatn() {
//   org.netlib.arpack.Sstatn.sstatn();
//  }

//  @Override
//  public void sstats() {
//   org.netlib.arpack.Sstats.sstats();
//  }

//  @Override
//  public void sstqrb(int n, float[] d, float[] e, float[] z, float[] work, org.netlib.util.intW info) {
//   org.netlib.arpack.Sstqrb.sstqrb(n, d, 0, e, 0, z, 0, work, 0, info);
//  }

//  @Override
//  public void sstqrb(int n, float[] d, int _d_offset, float[] e, int _e_offset, float[] z, int _z_offset, float[] work, int _work_offset, org.netlib.util.intW info) {
//   org.netlib.arpack.Sstqrb.sstqrb(n, d, _d_offset, e, _e_offset, z, _z_offset, work, _work_offset, info);
//  }
}
